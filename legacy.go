package govtk

import (
	"fmt"
	"io"
)

/*

notes / todo

- write helper function to extract binary from appended array to place here
- assert that only ascii / raw can go to legacy... otherwise we need to
  decode/encode before writing out. if desire is to get to legacy, migth just
  as well directly write to either these formats
- separate writing of headers per type into a function?
- get rid of all the []byte... its somewhat a mess now

*/

const (
	// header and description
	legacyHeader      = "# vtk DataFile Version 3.0\n"
	legacyDescription = "generated by github.com/maxvdkolk/govtk\n"

	// format options
	legacyAscii  = "ASCII"
	legacyBinary = "BINARY"

	// data types
	legacyDataset          = "DATASET"
	legacyStructuredPoint  = "STRUCTURED_POINTS"
	legacyStructuredGrid   = "STRUCTURED_GRID"
	legacyUnStructuredGrid = "UNSTRUCTURED_GRID"
	legacyPolydata         = "POLYDATA"
	legacyRectilinearGrid  = "RECTILINEAR_GRID"
	legacyFieldData        = "FIELD"
)

// LegacyWriter writes the Header towards the simple legacy format.
func LegacyWriter(h *Header, w io.Writer) error {

	// 1. header
	_, err := w.Write([]byte(legacyHeader))
	if err != nil {
		return err
	}

	// 2. description
	_, err = w.Write([]byte(legacyDescription))
	if err != nil {
		return err
	}

	// 3. data type: ascii/binary
	var format string
	if h.format == formatAscii {
		format = legacyAscii
	} else {
		format = legacyBinary
	}
	_, err = w.Write([]byte(format + "\n"))
	if err != nil {
		return err
	}

	// 4. geometry / topology of type
	_, err = w.Write([]byte(fmt.Sprintf("%s %v\n", legacyDataset, legacyStructuredPoint)))
	if err != nil {
		return err
	}

	// dimensions
	b := h.Grid.Extent
	nx := b[1] - b[0] + 1
	ny := b[3] - b[2] + 1
	nz := b[5] - b[4] + 1
	str := fmt.Sprintf("DIMENSIONS %d %d %d\n", nx, ny, nz)
	_, err = w.Write([]byte(str))
	if err != nil {
		return err
	}

	// origin
	if h.Grid.Origin == "" {
		str = fmt.Sprintf("ORIGIN 0 0 0\n")
	} else {
		str = h.Grid.Origin + "\n"
	}
	_, err = w.Write([]byte(str))
	if err != nil {
		return err
	}

	// spacing
	if h.Grid.Spacing == "" {
		str = fmt.Sprintf("SPACING 1 1 1\n")
	} else {
		str = h.Grid.Spacing + "\n"
	}
	_, err = w.Write([]byte(str))
	if err != nil {
		return err
	}

	// cell data that we have
	lp, _ := h.lastPiece()
	str = fmt.Sprintf("\nCELL_DATA %d\n", lp.NumberOfCells)
	_, err = w.Write([]byte(str))
	if err != nil {
		return err
	}

	// number of fields that we get
	str = fmt.Sprintf("FIELD FieldData %d\n", len(lp.CellData.Data))
	_, err = w.Write([]byte(str))
	if err != nil {
		return err
	}

	// for each data, dump into format
	for _, d := range lp.CellData.Data {
		str = fmt.Sprintf("%s %d %d %s\n", d.Name, d.NumberOfComponents, lp.NumberOfCells, "int") // todo make flexible
		_, err = w.Write([]byte(str))
		if err != nil {
			return err
		}

		// dump actual data
		_, err = w.Write(d.Data)
		if err != nil {
			return err
		}
		_, err = w.Write([]byte("\n"))
		if err != nil {
			return err
		}
	}

	return fmt.Errorf("Not yet implemented")
}
